#!/bin/bash
# ============================================================
#  system_health_check.sh
#  Post-update system health checker for Linux Mint
#  Version: 1.6.5
#  Usage: syscheck [OPTIONS]
#  --full    : run all extended checks (slower)
#  --log     : save output to /var/log/syscheck/
#  --help    : display help and exit
#  --version : display version and exit
# ============================================================

VERSION="1.6.5"
FULL_CHECK=false; SAVE_LOG=false

show_help() {
cat << EOF

Usage: syscheck [OPTION]...

Post-update system health checker for Linux Mint (v${VERSION}).
Scans disk, memory, CPU, packages, services, GPU, networking,
and more — reporting passes, warnings, and failures at a glance.

Options:
  --full     Run extended checks in addition to standard checks.
             Extended checks include:
               • SMART disk health (requires smartmontools)
               • Listening TCP ports
               • World-writable file scan (security audit)
               • SetUID/SetGID binary count audit

  --log      Save full output to a timestamped log file.
             Primary location (requires sudo on first run):
               /var/log/syscheck/syscheck_YYYY-MM-DD_HH-MM-SS.log
             Fallback if /var/log/syscheck/ is not accessible:
               ~/.local/share/syscheck/logs/syscheck_YYYY-MM-DD_HH-MM-SS.log

  --version  Display version number and exit.

  --help     Display this help message and exit.

Standard checks (always run):
  Disk & inode usage       Filesystem mount integrity
  RAM & swap pressure      Internet & DNS connectivity
  CPU load & temperature   Oversized log file detection
  Package health           NVIDIA GPU status & errors
  Failed systemd services  Critical journal errors (this boot)

Exit status:
  0   All checks passed
  1   One or more checks failed or produced warnings

Examples:
  syscheck                  Run standard checks
  syscheck --full           Run standard + extended checks
  syscheck --log            Run standard checks, save log
  syscheck --full --log     Run all checks and save log

Recommended optional packages:
  sudo apt install lm-sensors smartmontools
  sudo sensors-detect       (one-time CPU sensor setup)

EOF
}

for arg in "$@"; do
  case $arg in
    --full)    FULL_CHECK=true ;;
    --log)     SAVE_LOG=true ;;
    --version) echo "syscheck v${VERSION}"; exit 0 ;;
    --help)    show_help; exit 0 ;;
    *)
      echo "syscheck: unrecognized option '$arg'"
      echo "Try 'syscheck --help' for usage information."
      exit 1
      ;;
  esac
done

SYSTEM_LOG_DIR="/var/log/syscheck"
USER_LOG_DIR="$HOME/.local/share/syscheck/logs"
LOG_TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)

# Use /var/log/syscheck if accessible (or creatable), else fall back to user-local
if [ -w "$SYSTEM_LOG_DIR" ] 2>/dev/null || sudo mkdir -p "$SYSTEM_LOG_DIR" 2>/dev/null; then
  LOG_FILE="$SYSTEM_LOG_DIR/syscheck_${LOG_TIMESTAMP}.log"
else
  mkdir -p "$USER_LOG_DIR"
  LOG_FILE="$USER_LOG_DIR/syscheck_${LOG_TIMESTAMP}.log"
fi
PASS=0; WARN=0; FAIL=0

RED='\033[0;31m'; YELLOW='\033[1;33m'; GREEN='\033[0;32m'
CYAN='\033[0;36m'; BOLD='\033[1m'; RESET='\033[0m'

_out()   { echo -e "$@"; }
header() { _out "\n${BOLD}${CYAN}══════════════════════════════════════${RESET}"; _out "${BOLD}${CYAN}  $1${RESET}"; _out "${BOLD}${CYAN}══════════════════════════════════════${RESET}"; }
ok()     { _out "  ${GREEN}[✔] $1${RESET}";  ((PASS++)); }
warn()   { _out "  ${YELLOW}[⚠] $1${RESET}"; ((WARN++)); }
fail()   { _out "  ${RED}[✘] $1${RESET}";    ((FAIL++)); }
info()   { _out "  ${CYAN}[i]${RESET} $1"; }

if $SAVE_LOG; then
  exec > >(tee -a "$LOG_FILE") 2>&1
  info "Logging to $LOG_FILE"
fi

_out "\n${BOLD}Linux System Health Check v${VERSION} — $(date '+%A %B %d, %Y %H:%M:%S')${RESET}"
_out "Host: $(hostname)  |  Kernel: $(uname -r)  |  User: $USER"

# ── 1. DISK USAGE ────────────────────────────────────────────
header "1. Disk Usage"
while IFS= read -r line; do
  USE=$(echo "$line" | awk '{print $5}' | tr -d '%')
  MNT=$(echo "$line" | awk '{print $6}')
  [[ -z "$USE" || "$USE" == "Use%" ]] && continue
  if   [ "$USE" -ge 90 ]; then fail  "Disk $MNT is ${USE}% full — CRITICAL"
  elif [ "$USE" -ge 75 ]; then warn  "Disk $MNT is ${USE}% full — getting low"
  else                         ok    "Disk $MNT is ${USE}% full"
  fi
done < <(df -h --output=source,size,used,avail,pcent,target | awk 'NR>1 && $1 !~ /^(tmpfs|udev|efivarfs)/')

# ── 2. INODE USAGE ───────────────────────────────────────────
header "2. Inode Usage"
while IFS= read -r line; do
  USE=$(echo "$line" | awk '{print $5}' | tr -d '%')
  MNT=$(echo "$line" | awk '{print $6}')
  [[ -z "$USE" || "$USE" == "IUse%" || "$USE" == "-" ]] && continue
  if   [ "$USE" -ge 90 ]; then fail "Inodes on $MNT: ${USE}% used — CRITICAL"
  elif [ "$USE" -ge 75 ]; then warn "Inodes on $MNT: ${USE}% used"
  else                         ok   "Inodes on $MNT: ${USE}% used"
  fi
done < <(df -i | awk 'NR>1 && $1 !~ /^(tmpfs|udev)/')

# ── 3. MEMORY & SWAP ─────────────────────────────────────────
header "3. Memory & Swap"
MEM_TOTAL=$(free -m | awk '/^Mem/{print $2}')
MEM_USED=$(free  -m | awk '/^Mem/{print $3}')
MEM_PCT=$(( MEM_USED * 100 / MEM_TOTAL ))
if   [ "$MEM_PCT" -ge 90 ]; then fail "RAM: ${MEM_USED}MB / ${MEM_TOTAL}MB (${MEM_PCT}%)"
elif [ "$MEM_PCT" -ge 75 ]; then warn "RAM: ${MEM_USED}MB / ${MEM_TOTAL}MB (${MEM_PCT}%)"
else                              ok   "RAM: ${MEM_USED}MB / ${MEM_TOTAL}MB (${MEM_PCT}%)"
fi

SWAP_TOTAL=$(free -m | awk '/^Swap/{print $2}')
if [ "$SWAP_TOTAL" -gt 0 ]; then
  SWAP_USED=$(free -m | awk '/^Swap/{print $3}')
  SWAP_PCT=$(( SWAP_USED * 100 / SWAP_TOTAL ))
  if   [ "$SWAP_PCT" -ge 50 ]; then warn "Swap: ${SWAP_USED}MB / ${SWAP_TOTAL}MB (${SWAP_PCT}%) — high swap use may indicate RAM pressure"
  else                               ok   "Swap: ${SWAP_USED}MB / ${SWAP_TOTAL}MB (${SWAP_PCT}%)"
  fi
else
  info "No swap configured"
fi

# ── 4. CPU LOAD ──────────────────────────────────────────────
header "4. CPU Load"
CPU_CORES=$(nproc)
LOAD1=$(awk '{print $1}' /proc/loadavg)
LOAD5=$(awk '{print $2}' /proc/loadavg)
LOAD15=$(awk '{print $3}' /proc/loadavg)
LOAD_INT=${LOAD1%.*}
if   [ "$LOAD_INT" -gt "$((CPU_CORES * 2))" ]; then fail "Load average: $LOAD1 $LOAD5 $LOAD15 ($CPU_CORES cores) — very high"
elif [ "$LOAD_INT" -gt "$CPU_CORES" ];          then warn "Load average: $LOAD1 $LOAD5 $LOAD15 ($CPU_CORES cores) — above core count"
else                                                  ok   "Load average: $LOAD1 $LOAD5 $LOAD15 ($CPU_CORES cores)"
fi

if command -v sensors &>/dev/null; then
  CPU_TEMP=$(sensors 2>/dev/null | awk '/^(Tctl|Package id 0|Core 0|CPU Temperature)/{gsub(/[+°C]/,"",$2); print int($2); exit}')
  if [[ -n "$CPU_TEMP" && "$CPU_TEMP" =~ ^[0-9]+$ ]]; then
    if   [ "$CPU_TEMP" -ge 90 ]; then fail "CPU temp: ${CPU_TEMP}°C — CRITICAL"
    elif [ "$CPU_TEMP" -ge 75 ]; then warn "CPU temp: ${CPU_TEMP}°C — warm"
    else                               ok   "CPU temp: ${CPU_TEMP}°C"
    fi
  fi
else
  info "Install 'lm-sensors' for CPU temperature: sudo apt install lm-sensors"
fi

# ── 5. PACKAGE HEALTH ────────────────────────────────────────
header "5. Package Health"

UNCONF=$(dpkg --audit 2>/dev/null | wc -l)
if [ "$UNCONF" -gt 0 ]; then
  fail "$UNCONF package(s) need configuration — run: sudo dpkg --configure -a"
else
  ok "All packages properly configured"
fi

HELD=$(apt-mark showhold 2>/dev/null)
if [ -n "$HELD" ]; then
  warn "Held packages (won't auto-update): $HELD"
else
  ok "No held packages"
fi

PENDING=$(apt list --upgradable 2>/dev/null | grep -c -v "Listing...")
if [ "$PENDING" -gt 0 ]; then
  warn "$PENDING package(s) still upgradable — run: sudo apt upgrade"
else
  ok "System is fully up to date"
fi

AUTOREMOVE=$(apt-get --dry-run autoremove 2>/dev/null | grep -c "^Remov")
if [ "$AUTOREMOVE" -gt 0 ]; then
  info "$AUTOREMOVE package(s) can be removed — run: sudo apt autoremove"
fi

# ── 6. SYSTEMD SERVICES ──────────────────────────────────────
header "6. Failed Systemd Services"
# systemctl --failed --no-legend output format: "● unit.service  loaded failed failed  Description"
# $1 is the bullet character ●, $2 is the actual unit name — filter to only .service/.socket/.mount etc.
FAILED_SERVICES=$(systemctl --failed --no-legend 2>/dev/null \
  | awk '{print $2}' \
  | grep -E '\.(service|socket|mount|target|timer|path)$')
if [ -z "$FAILED_SERVICES" ]; then
  ok "No failed systemd services"
else
  while IFS= read -r svc; do
    [ -n "$svc" ] && fail "Service failed: $svc"
  done <<< "$FAILED_SERVICES"
  info "Fix with: sudo systemctl status <service>  |  sudo journalctl -xe"
fi

# ── 7. JOURNAL ERRORS ────────────────────────────────────────
header "7. Critical Journal Errors (this boot)"
# ── Hard filters: confirmed hardware quirks on ASUS ROG + AMD Ryzen hybrid GPU ──
#   nvidia-wmi-ec-backlight : ACPI backlight quirk (kernel module, hyphens AND underscores)
#   ACPI BIOS Error / ACPI Error : ASUS BIOS ACPI table mismatches, cosmetic
#   RDSEED32 is broken      : documented AMD CPU errata, no functional impact
#   asus_wmi /bin/false     : module is intentionally blocklisted, not a real error
#   hidpp_root_get_protocol : Logitech HID++ version probe on device connect
#   sap_server / sap-server : Bluetooth SAP profile not loaded, harmless on laptops
#   pam_ecryptfs seteuid    : screensaver unlock ecryptfs probe, benign
#   profiles inconsistent   : PipeWire audio profile count mismatch on BT connect
#   gkr-pam unlock/control  : Cinnamon+LightDM timing artifact — PAM fires before
#                             gnome-keyring-daemon starts; daemon runs fine during
#                             session, keyring is accessible, errors are cosmetic
#   pam_unix cinnamon-screensaver conversation failed / could not identify password :
#                             ecryptfs PAM module interference in screensaver unlock
#                             path — "could not identify password" (not "wrong password")
#                             confirms this is a PAM config artifact, not a real auth failure
#   ext_io_disconnected Hands-Free Voice gateway : Bluetooth headset ungraceful disconnect
# ── Soft filters: counted separately but not flagged as failures ──
#   PCIe Bus Error ACSViol/UnsupReq on [1022:14db] : AMD Ryzen PCIe root port fires
#   during dGPU power state transitions on ASUS ROG hybrid GPU systems. Null TLP
#   headers confirm spurious. Non-fatal and does not indicate hardware failure.
RAW_ERRS=$(journalctl -p err -b 0 --no-pager -q 2>/dev/null)

HARD_FILTERED=$(echo "$RAW_ERRS" \
  | grep -v "nvidia.wmi.ec.backlight" \
  | grep -v "ACPI BIOS Error\|ACPI Error" \
  | grep -v "RDSEED32 is broken" \
  | grep -v "asus_wmi.*retcode\|/bin/false.*asus" \
  | grep -v "hidpp_root_get_protocol_version" \
  | grep -v "sap_server_register\|sap-server" \
  | grep -v "pam_ecryptfs" \
  | grep -v "profiles inconsistent" \
  | grep -v "gkr-pam:.*unlock.*keyring\|gkr-pam:.*daemon control file" \
  | grep -v "pam_unix.*cinnamon-screensaver.*conversation failed\|pam_unix.*cinnamon-screensaver.*could not identify password" \
  | grep -v "ext_io_disconnected.*Hands-Free Voice gateway" \
  | grep -v "^.\{,80\}kernel:[[:space:]]*$")  # blank kernel log lines

PCIE_ACS=$(echo "$HARD_FILTERED" | grep -c "PCIe Bus Error\|ACSViol\|UnsupReq\|TLP Header\|error status/mask" || true)

REAL_ERRS=$(echo "$HARD_FILTERED" \
  | grep -v "PCIe Bus Error\|ACSViol\|UnsupReq\|TLP Header\|error status/mask" \
  | grep -c "." || true)

RAW_COUNT=$(echo "$RAW_ERRS" | grep -c "." || true)
HARD_NOISE=$(( RAW_COUNT - PCIE_ACS - REAL_ERRS ))

if   [ "$REAL_ERRS" -eq 0 ] && [ "$RAW_COUNT" -eq 0 ]; then
  ok "No critical errors in journal this boot"
elif [ "$REAL_ERRS" -eq 0 ]; then
  ok "No significant errors in journal ($HARD_NOISE known-harmless noise lines filtered)"
  [ "$PCIE_ACS" -gt 0 ] && info "PCIe ACS/UnsupReq: $PCIE_ACS lines (AMD Ryzen hybrid GPU power state quirk — non-fatal on ASUS ROG)"
elif [ "$REAL_ERRS" -lt 10 ]; then
  warn "$REAL_ERRS error(s) in journal after filtering — run: journalctl -p err -b 0"
  [ "$PCIE_ACS" -gt 0 ] && info "PCIe ACS/UnsupReq: $PCIE_ACS lines (AMD Ryzen hybrid GPU power state quirk — non-fatal on ASUS ROG)"
else
  fail "$REAL_ERRS errors in journal this boot — run: journalctl -p err -b 0"
  [ "$PCIE_ACS" -gt 0 ] && info "PCIe ACS/UnsupReq: $PCIE_ACS lines (AMD Ryzen hybrid GPU power state quirk — non-fatal on ASUS ROG)"
fi

# ── 8. NVIDIA GPU ────────────────────────────────────────────
header "8. NVIDIA GPU (RTX 5070)"
if command -v nvidia-smi &>/dev/null; then
  if nvidia-smi &>/dev/null; then
    GPU_NAME=$(nvidia-smi  --query-gpu=name           --format=csv,noheader 2>/dev/null)
    GPU_DRV=$(nvidia-smi   --query-gpu=driver_version --format=csv,noheader 2>/dev/null)
    GPU_TEMP=$(nvidia-smi  --query-gpu=temperature.gpu --format=csv,noheader,nounits 2>/dev/null)
    GPU_MEM_U=$(nvidia-smi --query-gpu=memory.used    --format=csv,noheader 2>/dev/null)
    GPU_MEM_T=$(nvidia-smi --query-gpu=memory.total   --format=csv,noheader 2>/dev/null)
    ok "GPU: $GPU_NAME  |  Driver: $GPU_DRV"
    ok "VRAM: $GPU_MEM_U / $GPU_MEM_T"
    if [[ "$GPU_TEMP" =~ ^[0-9]+$ ]]; then
      if   [ "$GPU_TEMP" -ge 90 ]; then fail "GPU temp: ${GPU_TEMP}°C — CRITICAL"
      elif [ "$GPU_TEMP" -ge 80 ]; then warn "GPU temp: ${GPU_TEMP}°C — warm"
      else                               ok   "GPU temp: ${GPU_TEMP}°C"
      fi
    fi
    # Only flag real GPU faults — Xid errors are the authoritative NVIDIA fault indicator.
    # Filtering on generic "error" strings produces false positives from benign driver messages.
    GPU_XIDS=$(dmesg 2>/dev/null | grep -iE "NVRM.*Xid|Xid.*NVRM" | grep -oP "Xid \K[0-9]+" | sort -un)
    if [ -n "$GPU_XIDS" ]; then
      warn "NVIDIA Xid fault code(s) detected in dmesg: $GPU_XIDS — run: dmesg | grep -iE 'Xid'"
    else
      ok "No NVIDIA Xid fault codes in dmesg"
    fi
  else
    fail "nvidia-smi found but driver not responding — module may not be loaded"
    info "Try: sudo modprobe nvidia  |  or check: lsmod | grep nvidia"
  fi
else
  warn "nvidia-smi not found — NVIDIA driver may not be installed or active"
  info "Check driver: ubuntu-drivers devices  |  Install: sudo ubuntu-drivers autoinstall"
fi

# ── 9. FILESYSTEM INTEGRITY ──────────────────────────────────
header "9. Filesystem Integrity"
RO_MOUNTS=$(awk '$4 ~ /(^|,)ro(,|$)/ && $1 !~ /^(proc|sys|cgroup|sysfs|devtmpfs|securityfs)/' /proc/mounts | wc -l)
if [ "$RO_MOUNTS" -gt 0 ]; then
  fail "$RO_MOUNTS unexpected read-only mount(s) — possible filesystem errors"
else
  ok "No unexpected read-only mounts"
fi

TMP_SIZE=$(du -sh /tmp 2>/dev/null | cut -f1)
info "/tmp usage: $TMP_SIZE"
ok "Filesystem checks complete"

# ── 10. NETWORK ──────────────────────────────────────────────
header "10. Network Connectivity"
if ping -c 1 -W 3 8.8.8.8 &>/dev/null; then
  ok "Internet connectivity: OK"
else
  fail "No internet connectivity (ping 8.8.8.8 failed)"
fi

if ping -c 1 -W 3 google.com &>/dev/null; then
  ok "DNS resolution: OK"
else
  warn "DNS resolution may be failing — try: ping google.com"
fi

# ── 11. LOGS ─────────────────────────────────────────────────
header "11. Log File Health"
LOG_SIZE_MB=$(du -sm /var/log 2>/dev/null | cut -f1)
LOG_SIZE_H=$(du -sh /var/log 2>/dev/null | cut -f1)

# Note: /var/log contains both systemd journal (/var/log/journal/) and traditional
# text logs (syslog, kern.log, etc). journalctl --vacuum only clears journal data.
# If vacuum freed 0B but /var/log is still large, the culprit is traditional logs.
JOURNAL_SIZE_MB=$(du -sm /var/log/journal 2>/dev/null | cut -f1)
JOURNAL_SIZE_MB=${JOURNAL_SIZE_MB:-0}
TEXTLOG_SIZE_MB=$(( LOG_SIZE_MB - JOURNAL_SIZE_MB ))

if   [ "$LOG_SIZE_MB" -ge 2048 ]; then
  fail "/var/log total: ${LOG_SIZE_H} — very large"
  [ "$JOURNAL_SIZE_MB" -gt 200 ] && info "  Journal portion: ~${JOURNAL_SIZE_MB}MB — run: sudo journalctl --vacuum-size=200M"
  [ "$TEXTLOG_SIZE_MB" -gt 200 ] && info "  Text logs portion: ~${TEXTLOG_SIZE_MB}MB — run: sudo logrotate --force /etc/logrotate.conf"
elif [ "$LOG_SIZE_MB" -ge 500 ]; then
  warn "/var/log total: ${LOG_SIZE_H} — getting large"
  [ "$JOURNAL_SIZE_MB" -gt 200 ] && info "  Journal portion: ~${JOURNAL_SIZE_MB}MB — run: sudo journalctl --vacuum-size=200M"
  [ "$TEXTLOG_SIZE_MB" -gt 200 ] && info "  Text logs portion: ~${TEXTLOG_SIZE_MB}MB — run: sudo logrotate --force /etc/logrotate.conf"
else
  ok "/var/log total: ${LOG_SIZE_H}"
fi

# Flag any single log file over 100MB
while IFS= read -r logfile; do
  SIZE_MB=$(du -m "$logfile" 2>/dev/null | cut -f1)
  if [[ "$SIZE_MB" =~ ^[0-9]+$ ]] && [ "$SIZE_MB" -gt 100 ]; then
    warn "Large log file: $logfile (${SIZE_MB}MB)"
  fi
done < <(find /var/log -maxdepth 2 -type f ! -path "*/journal/*" 2>/dev/null)
ok "Log check complete"

# ── 12. EXTENDED: --full only ────────────────────────────────
if $FULL_CHECK; then

  header "12. [FULL] SMART Disk Health"
  if command -v smartctl &>/dev/null; then
    for disk in /dev/sd? /dev/nvme?n1; do
      [ -b "$disk" ] || continue
      SMART=$(sudo smartctl -H "$disk" 2>/dev/null)
      if echo "$SMART" | grep -qi "PASSED"; then
        ok "SMART $disk: PASSED"
      elif echo "$SMART" | grep -qi "FAILED"; then
        fail "SMART $disk: FAILED — backup data immediately!"
      else
        info "SMART $disk: could not read — ensure sudoers entry exists: $USER ALL=(ALL) NOPASSWD: /usr/sbin/smartctl"
      fi
    done
  else
    info "Install 'smartmontools': sudo apt install smartmontools"
  fi

  header "13. [FULL] Listening Ports"
  if command -v ss &>/dev/null; then
    info "Listening TCP sockets:"
    ss -tlnp 2>/dev/null | awk 'NR>1{printf "    %-30s %s\n", $4, $6}'
  fi

  header "14. [FULL] World-Writable Files (security)"
  info "Scanning — this may take a moment..."
  # Exclude known-safe sources of world-writable files:
  #   - Proton/Wine (Steam & Lutris) ship DLLs and exes with o+w by design
  #   - LM Studio bundles CUDA/Vulkan/Python libs with o+w
  #   - Flatpak user data lives in ~/.var/app/
  #   - Standard exclusions: /tmp, /proc, /sys, /dev, /run, /var/tmp
  WW=$(find / -xdev -type f -perm -o+w \
    ! -path "/tmp/*"              ! -path "/proc/*"             ! -path "/sys/*"       \
    ! -path "/dev/*"              ! -path "/run/*"              ! -path "/var/tmp/*"   \
    ! -path "/snap/*"             ! -path "/var/lib/snapd/*"    ! -path "/var/snap/*"  \
    ! -path "/var/lib/flatpak/*"  \
    ! -path "/home/*/.var/app/*"  \
    ! -path "/home/*/.steam/*"    \
    ! -path "/home/*/.local/share/Steam/*" \
    ! -path "/home/*/.lmstudio/*" \
    ! -path "/home/*/.gradle/jdks/*" \
    ! -path "/home/*/.cache/flatpak/*" \
    2>/dev/null | wc -l)
  if   [ "$WW" -gt 20 ]; then fail "$WW unexpected world-writable file(s) — run: find / -xdev -type f -perm -o+w ! -path '/snap/*' ! -path '/tmp/*' ! -path '/home/*/.steam/*' ! -path '/home/*/.var/*' 2>/dev/null"
  elif [ "$WW" -gt 0 ];  then warn "$WW world-writable file(s) outside known-safe paths — worth reviewing"
  else                         ok   "No unexpected world-writable files"
  fi

  header "15. [FULL] SetUID/SetGID Binaries"
  SUID_COUNT=$(find / -xdev -type f \( -perm -4000 -o -perm -2000 \) ! -path "/proc/*" 2>/dev/null | wc -l)
  # Snap packages bundle their own binaries each with setUID bits, so 150-250 is normal
  # on Ubuntu/Mint systems with snaps installed. Flag only truly unusual counts.
  info "$SUID_COUNT setUID/setGID binaries found (normal range: up to ~250 with snaps)"
  if [ "$SUID_COUNT" -gt 300 ]; then
    warn "Unusually high setUID/setGID count ($SUID_COUNT) — review with: find / -xdev -perm /6000 -type f 2>/dev/null"
  else
    ok "SetUID/setGID count looks normal"
  fi

fi

# ── SUMMARY ──────────────────────────────────────────────────
_out "\n${BOLD}══════════════════════════════════════${RESET}"
_out "${BOLD}  SUMMARY${RESET}"
_out "${BOLD}══════════════════════════════════════${RESET}"
_out "  ${GREEN}✔ Passed:   $PASS${RESET}"
_out "  ${YELLOW}⚠ Warnings: $WARN${RESET}"
_out "  ${RED}✘ Failed:   $FAIL${RESET}"
_out ""
if   [ "$FAIL" -gt 0 ]; then _out "${RED}${BOLD}  ✘ System has critical issues that need attention.${RESET}"
elif [ "$WARN" -gt 0 ]; then _out "${YELLOW}${BOLD}  ⚠ System is functional but has warnings worth reviewing.${RESET}"
else                          _out "${GREEN}${BOLD}  ✔ All checks passed! System looks healthy.${RESET}"
fi

$SAVE_LOG && _out "\n  Log saved to: $LOG_FILE"
_out ""
